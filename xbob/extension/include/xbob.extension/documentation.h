/**
 * @file xbob/extension/include/xbob.extension/documentation.h
 * @date Fri Feb 21 18:29:37 CET 2014
 * @author Manuel Guenther <manuel.guenther@idiap.ch>
 *
 * @brief Implements a few functions to generate doc strings
 *
 * Copyright (C) 2011-2014 Idiap Research Institute, Martigny, Switzerland
 */

#ifndef XBOB_EXTENSION_DOCUMENTATION_H_INCLUDED
#define XBOB_EXTENSION_DOCUMENTATION_H_INCLUDED

#include <string>
#include <set>
#include <stdexcept>

namespace xbob{
  namespace extension{

    /**
     * Use a static object of this class to document a variable.
     * This class can be used to document both global variables as well as class member variables.
     */
    class VariableDoc {
      friend class ClassDoc;
      public:
        /**
         * Generates a VariableDoc object. Please assure that use use this as a static member variable.
         * @param variable_name      The name of the variable
         * @param variable_type      The type of the variable, e.g., "float" or "array_like (float, 2D)"
         * @param short_description  A short description of the variable
         * @param long_description   An optional long description of the variable
         */
        VariableDoc(
          const char* const variable_name,
          const char* const variable_type,
          const char* const short_description,
          const char* const long_description = 0
        );

        /**
         * Returns the name of the variable that is documented, i.e., the "variable_name" parameter of the constructor.
         */
        char* name() const {return const_cast<char*>(variable_name.c_str());}

        /**
         * Generates and returns the documentation string.
         * @param alignment The default alignment is 80 characters.
         *                  Since the documentation is automatically indented by 4 spaces in the python documentation, we need to subtract these values here...
         * @return The documentation string, properly aligned, possibly including "ToDo's" for detected problems.
         */
        char* doc(const unsigned alignment = 76) const;

      private:
         // variable name and type
         std::string variable_name;
         std::string variable_type;
         // variable description
         std::string variable_description;

         // an internal string that is generated and returned.
         mutable std::string description;

    };

    /**
     * Use a static object of this class to generate a properly aligned and numpydoc compatible function documentation.
     * Documentation generated by this class can be used for non-member functions as well as for member functions and constructors.
     */
    class FunctionDoc {
      friend class ClassDoc;
      public:
        /**
         * Generates a FunctionDoc object. Please assure that use use this as a static member variable.
         * @param function_name     The name of the function you want to document
         * @param short_description A short description of what the function does
         * @param long_description  An optional long description of the function
         */
        FunctionDoc(
          const char* const function_name,
          const char* const short_description,
          const char* const long_description = 0
        );

        /**
         * Add a prototypical call for this function by defining the parameters and the return values.
         * This function has to be called at least ones.
         * @param variables    A string containing a comma-separated list of parameters, e.g., "param1, param2"
         * @param return_value A string containing a comma-separated list of return values, e.g., "retval1, retval2".
         *                     If the function does not return anything, this value can be left at its default "None".
         *                     To document a constructor, please use "" as return value.
         */
        FunctionDoc& add_prototype(
          const char* const variables,
          const char* const return_value = "None"
        );

        /**
         * Add the documentation for a parameter added with the add_prototype function
         * @param parameter_name   The name of the parameter, e.g. "param1"
         * @param parameter_type   The type of the parameter, e.g. "float" or "array_like (float, 2D)"; indicate if the parameter is optional here
         * @param parameter_description  The description of the parameter
         */
        FunctionDoc& add_parameter(
          const char* const parameter_name,
          const char* const parameter_type,
          const char* const parameter_description
        );
        /**
         * Add the documentation of a return value added with the add_prototype function
         * @param return_name   The name assigned to the return value
         * @param return_type   The tape of the returned value
         * @param return_description  The description of the return value
         */
        FunctionDoc& add_return(
          const char* const return_name,
          const char* const return_type,
          const char* const return_description
        );


        /**
         * Returns the name of the function that is documented (i.e., the function_name parameter of the constructor)
         */
        const char* const name() const {return function_name.c_str();}

        /**
         * Generates and returns the documentation string.
         * A ..todo:: directive is added for each detected mistake.
         * @param alignment The default alignment is 80 characters.
         *                  Since the documentation is automatically indented by 4 spaces in the python documentation, we need to subtract these values here...
         * @return The documentation string, properly aligned, possibly including "ToDo's" for detected problems.
         */
        const char* const doc(const unsigned alignment = 76) const;


      private:
        // the function name
        std::string function_name;
        // the description
        std::string function_description;
        // prototypes
        std::vector<std::string> prototype_variables;
        std::vector<std::string> prototype_returns;
        // parameter documentation
        std::vector<std::string> parameter_names;
        std::vector<std::string> parameter_types;
        std::vector<std::string> parameter_descriptions;
        // return value documentation
        std::vector<std::string> return_names;
        std::vector<std::string> return_types;
        std::vector<std::string> return_descriptions;

        // an internal string that is generated and returned.
        mutable std::string description;
    };


    /**
     * Use a static object of this class to document a class.
     * Documenting a class includes the documentation of the constructor,
     * but not the documentation of the other member functions.
     * For those, please use the FunctionDoc class.
     */
    class ClassDoc{
      public:
        /**
         * Generates a ClassDoc object. Please assure that use use this as a static member variable.
         * @param class_name  The name of the class to be documented
         * @param short_description  A short description of the class
         * @param long_description  An optional long description of the class
         */
        ClassDoc(
          const char* const class_name,
          const char* const short_description,
          const char* const long_description = 0
        );

        /**
         * Add the documentation of the constructor.
         * This function can be called only once.
         * @param constructor_documentation  An instance of the FunctionDoc class that contains the documentation of the constructor.
         *                                   Please read the documentation of that class on how to generate constructor documentations.
         */
        ClassDoc& add_constructor(
          const FunctionDoc& constructor_documentation
        );

        /**
         * Adds the given function to the highlighted section.
         * @param function_documentation   An instance of the FunctionDoc class that should be highlighted.
         */
        ClassDoc& highlight(
          const FunctionDoc& function_documentation
        );

        /**
         * Adds the given variable to the highlighted section.
         * @param function_documentation   An instance of the FunctionDoc class that should be highlighted.
         */
        ClassDoc& highlight(
          const VariableDoc& variable_documentation
        );

        /**
         * Returns the name of the class that is documented, i.e., the "class_name" parameter of the constructor.
         */
        char* name() const {return const_cast<char*>(class_name.c_str());}

        /**
         * Generates and returns the documentation string.
         * @param alignment The default alignment is 80 characters.
         *                  Since the documentation is automatically indented by 4 spaces in the python documentation, we need to subtract these values here...
         * @return The documentation string, properly aligned, possibly including "ToDo's" for detected problems.
         */
        char* doc(const unsigned alignment = 76) const;


      private:
        // class name
        std::string class_name;
        // class description
        std::string class_description;
        // constructor; should be only one, though
        std::vector<FunctionDoc> constructor;

        // highlighting
        std::vector<FunctionDoc> highlighted_functions;
        std::vector<VariableDoc> highlighted_variables;

        // an internal string that is generated and returned.
        mutable std::string description;
    };

  }
}


/////////////////////////////////////////////////////////////
//////////////////// Implementations ////////////////////////
/////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////
/// helper functions
// TODO: remove
#include <iostream>

#ifndef XBOB_SHORT_DOCSTRINGS
// removes leading and trailing spaces
static std::string _strip(const std::string& str, char sep = ' '){
  unsigned first = 0, last = str.size();
  while (first < str.size() && str[first] == sep) ++first;
  while (last > 0 && str[last-1] == sep) --last;
  return str.substr(first, last-first);
}

// splits the given string by the given separator
static std::vector<std::string> _split(const std::string& str, char limit = ' '){
  std::vector<std::string> splits;
  int i = str.find(limit);
  unsigned j = 0;
  while (i != (int)std::string::npos){
    splits.push_back(str.substr(j, i-j));
    j = i+1;
    i = str.find(limit, j);
  }
  if (j < str.size()) splits.push_back(str.substr(j));
  return splits;
}

// aligns the given string using the given indent to the given alignment length;
// line breaks are handled carefully.
//static std::string _align(std::string str, unsigned first_line_indent=0, unsigned other_line_indent=4, unsigned alignment=76){
static std::string _align(std::string str, unsigned indent=0, unsigned alignment=76){
  // first, split the newlines
  auto lines = _split(str, '\n');

  std::string aligned;
  unsigned current_indent = indent;
  bool first_line = true;
  // now, split each line
  for (auto line : lines){
    auto words = _split(line);
    // fill in one line
    unsigned len = 0;
    for (auto word : words){
      if (aligned.empty() || len + word.size() >= alignment || !first_line){
        // line reached alignment
        if (!aligned.empty()){
          aligned += "\n";
        }
        // add indent and start new line
        for (unsigned j = current_indent; j--;) aligned += " ";
        len = current_indent;
        first_line = true;
      }
      // increase indent?
      const std::string& w = words[0];
      if ((w.size() == 2 && w[0] == '.' && w[1] == '.') ||
          (w.size() >= 1 && '0' <= w[0] && '9' >= w[0]) ||
          (w.size() == 1 && '*' == w[0]) ){
        current_indent = indent + 3;
      }
      // add word
      aligned += word + " ";
      len += word.size() + 1;
    }
    current_indent = indent;
    aligned += "\n";
    first_line = false;
  }

  return aligned;
}

// Aligns the parameter description
static void _align_parameter(std::string& str, const std::string& name, const std::string& type, const std::string& description, unsigned alignment=76){
  str += _align(name + " : " + type + "", 0, alignment);
  str += _align(description, 4, alignment);
}

static std::string _prototype(const std::string& name, const std::string& variables, const std::string& retval){
  if (retval.empty())
    return name + "(" + variables + ")";
  else
    return name + "(" + variables + ") -> " + retval;
}

static void _check(std::string& doc, const std::vector<std::string>& vars, const std::vector<std::string>& docs, const std::string& type){
  // check that all parameters are documented. If not, add a TODO
  std::set<std::string> undoc;
  std::set<std::string> unused;
  // gather parameters
  for (auto p : vars){
    for (auto s : _split(p, ',')){
      undoc.insert(_strip(s));
    }
  }
  for (auto p : docs){
    for (auto s : _split(p, ',')){
      std::string x = _strip(s);
      if (undoc.find(x) == undoc.end()){
        unused.insert(x);
      } else {
        undoc.erase(x);
     }
    }
  }
  if (undoc.size()){
    std::string all;
    for (auto p : undoc){
      if (p != "None"){
        if (!all.empty()) all += ", ";
        all += p;
      }
    }
    if (!all.empty()){
      doc += _align(".. todo:: The " + type + "(s) '" + all + "' are used, but not documented.", 0, (unsigned)-1);
    }
  }
  if (unused.size()){
    std::string all;
    for (auto p : unused){
      if (!all.empty()) all += ", ";
      all += p;
    }
    doc += _align(".. todo:: The " + type + "(s) '" + all + "' are documented, but nowhere used.", 0, (unsigned)-1);
  }
}

#endif // ! XBOB_SHORT_DOCSTRINGS


/////////////////////////////////////////////////////////////
/// FunctionDoc

inline xbob::extension::FunctionDoc::FunctionDoc(
  const char* const function_name,
  const char* const short_description,
  const char* const long_description
) : function_name(function_name), function_description(short_description)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  if (long_description){
    function_description += "\n";
    function_description += long_description;
  }
#endif
}

inline xbob::extension::FunctionDoc& xbob::extension::FunctionDoc::add_prototype(
  const char* const variables,
  const char* const return_values
){
#ifndef XBOB_SHORT_DOCSTRINGS
  prototype_variables.push_back(variables);
  prototype_returns.push_back(return_values);
#endif // XBOB_SHORT_DOCSTRINGS
  return *this;
}

inline xbob::extension::FunctionDoc& xbob::extension::FunctionDoc::add_parameter(
  const char* const parameter_name,
  const char* const parameter_type,
  const char* const parameter_description
)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  parameter_names.push_back(parameter_name);
  parameter_types.push_back(parameter_type);
  parameter_descriptions.push_back(parameter_description);
#endif // XBOB_SHORT_DOCSTRINGS
  return *this;
}

inline xbob::extension::FunctionDoc& xbob::extension::FunctionDoc::add_return(
  const char* const parameter_name,
  const char* const parameter_type,
  const char* const parameter_description
)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  return_names.push_back(parameter_name);
  return_types.push_back(parameter_type);
  return_descriptions.push_back(parameter_description);
#endif // XBOB_SHORT_DOCSTRINGS
  return *this;
}

inline const char* const xbob::extension::FunctionDoc::doc(
  const unsigned alignment
) const
{
#ifdef XBOB_SHORT_DOCSTRINGS
  return function_description.c_str();
#else
  description = "";
  switch(prototype_variables.size()){
    case 0:
      description = _align(".. todo:: Please use ``FunctionDoc.add_prototype`` to add at least one prototypical way to call this function", 0, (unsigned)-1);
      break;
    case 1:
      // only one way to call; use the default way
      description = _align(_prototype(function_name, prototype_variables[0], prototype_returns[0]) + "\n", 0, alignment);
      break;
    default:
      // several ways to call; list them
      for (unsigned n = 0; n < prototype_variables.size(); ++n)
        description += _align("* " + _prototype(function_name, prototype_variables[n], prototype_returns[n]) + "\n", 0, alignment);
  }
  // add function description
  description += "\n" + _align(function_description, 0, alignment) + "\n";

  // check that all parameters are documented
  _check(description, prototype_variables, parameter_names, "parameter");

  // check that all return values are documented
  _check(description, prototype_returns, return_names, "return value");

  if (!parameter_names.empty()){
    // add parameter description
    description += "\n" + _align("Parameters") + _align("----------");
    for (unsigned i = 0; i < parameter_names.size(); ++i){
      _align_parameter(description, parameter_names[i], parameter_types[i], parameter_descriptions[i], alignment);
    }
  }

  if (!return_names.empty()){
    // add return value description
    description += "\n" + _align("Returns") + _align("--------");
    for (unsigned i = 0; i < return_names.size(); ++i){
      _align_parameter(description, return_names[i], return_types[i], return_descriptions[i], alignment);
    }
  }

//  std::cout << description << std::endl;

  // return the description
  return description.c_str();
#endif // XBOB_SHORT_DOCSTRINGS
}


/////////////////////////////////////////////////////////////
/// ClassDoc

inline xbob::extension::ClassDoc::ClassDoc(
  const char* const class_name,
  const char* const short_description,
  const char* const long_description
) : class_name(class_name), class_description(short_description)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  if (long_description){
    class_description += "\n";
    class_description += long_description;
  }
#endif // ! XBOB_SHORT_DOCSTRINGS
}

inline xbob::extension::ClassDoc& xbob::extension::ClassDoc::add_constructor(
  const xbob::extension::FunctionDoc& constructor_documentation
)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  if (!constructor.empty()){
    throw std::runtime_error("The class documentation can have only a single constructor documentation");
  }
  constructor.push_back(constructor_documentation);
#endif // XBOB_SHORT_DOCSTRINGS
  return *this;
}

inline xbob::extension::ClassDoc& xbob::extension::ClassDoc::highlight(
  const xbob::extension::FunctionDoc& function_documentation
)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  highlighted_functions.push_back(function_documentation);
#endif // XBOB_SHORT_DOCSTRINGS
  return *this;
}

inline xbob::extension::ClassDoc& xbob::extension::ClassDoc::highlight(
  const xbob::extension::VariableDoc& variable_documentation
)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  highlighted_variables.push_back(variable_documentation);
#endif // XBOB_SHORT_DOCSTRINGS
  return *this;
}


inline char* xbob::extension::ClassDoc::doc(
  const unsigned alignment
) const
{
#ifdef XBOB_SHORT_DOCSTRINGS
  return const_cast<char*>(class_description.c_str());
#else
  description = _align(class_description, 0, alignment);
  if (!constructor.empty()){
    description += _align("\n**Constructor Documentation** :\n\n");
    description += constructor.front().doc(alignment);
  }
  if (!highlighted_variables.empty()){
    description += "\n" + _align("Attributes") + _align("----------");
    for (auto hightlight : highlighted_variables){
      description += _align(hightlight.variable_name, 0, alignment) + _align(_split(hightlight.variable_description, '\n')[0], 4, alignment);
    }
  }
  if (!highlighted_functions.empty()){
    description += "\n" + _align("Methods") + _align("-------");
    for (auto hightlight : highlighted_functions){
      description += _align(hightlight.function_name, 0, alignment) + _align(_split(hightlight.function_description, '\n')[0], 4, alignment);
    }
  }
  return const_cast<char*>(description.c_str());
#endif // XBOB_SHORT_DOCSTRINGS
}

/////////////////////////////////////////////////////////////
/// VariableDoc

inline xbob::extension::VariableDoc::VariableDoc(
  const char* const variable_name,
  const char* const variable_type,
  const char* const short_description,
  const char* const long_description
) : variable_name(variable_name), variable_type(variable_type), variable_description(short_description)
{
#ifndef XBOB_SHORT_DOCSTRINGS
  if (long_description){
    variable_description += "\n";
    variable_description += long_description;
  }
#endif // ! XBOB_SHORT_DOCSTRINGS
}

inline char* xbob::extension::VariableDoc::doc(
  const unsigned alignment
) const
{
#ifdef XBOB_SHORT_DOCSTRINGS
  return const_cast<char*>(variable_description.c_str());
#else
  // The numpydoc standard does not use variable types, so I came up with my own way of it
  description = _align("**" + variable_type + "**  <-- " + variable_description, 0, alignment);
  return const_cast<char*>(description.c_str());
#endif // XBOB_SHORT_DOCSTRINGS
}

#endif // XBOB_EXTENSION_DOCUMENTATION_H_INCLUDED

