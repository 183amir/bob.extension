import os

HEADER = (
  '\n'
  '# For both C and C++\n'
  'set(COMMON_FLAGS "-pedantic -Wall")\n'
  'if (WIN32)\n'
  '  set(COMMON_FLAGS "-D_WIN32_WINNT=0x501") # Set min. Windows version to XP\n'
  'else(WIN32)\n'
  '  set(COMMON_FLAGS "${COMMON_FLAGS} -pthread")\n'
  'endif (WIN32)\n'
  'if (NOT CMAKE_COMPILER_IS_GNUCC)\n'
  '  # Then, it must be clang/clang++\n'
  '  set(COMMON_FLAGS "${COMMON_FLAGS} -Qunused-arguments")\n'
  'endif ()\n'
  '\n'
  '# Force __LP64__ scheme on Mac OSX\n'
  'if(APPLE)\n'
  '  set(COMMON_FLAGS "${COMMON_FLAGS} -m64")\n'
  '  # Bogus on OSX?\n'
  '  set(CMAKE_INCLUDE_SYSTEM_FLAG_C "-isystem ")\n'
  '  set(CMAKE_INCLUDE_SYSTEM_FLAG_CXX "-isystem ")\n'
  'endif(APPLE)\n'
  '\n'
  '# For both RELEASE and DEBUG builds\n'
  'if(APPLE AND CMAKE_COMPILER_IS_GNUCC)\n'
  '  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS "4.4")\n'
  '    message(FATAL_ERROR "Minimum GCC version required on OSX is 4.4, but you have ${CMAKE_CXX_COMPILER_VERSION}")\n'
  '  endif()\n'
  '  set(COMMON_FLAGS "${COMMON_FLAGS} -Wno-long-long -Wno-variadic-macros")\n'
  '  set(COMMON_CXX_FLAGS "-std=c++0x")\n'
  '  set(COMMON_C_FLAGS "-std=c99")\n'
  'elseif(WIN32)\n'
  '  set(COMMON_CXX_FLAGS "-std=gnu++0x")\n'
  '  set(COMMON_C_FLAGS "-std=gnu99")\n'
  'else()\n'
  '  set(COMMON_CXX_FLAGS "-std=c++0x")\n'
  '  set(COMMON_C_FLAGS "-std=c99")\n'
  'endif()\n'
  '\n'
  '# For specific builds\n'
  'set(COMMON_RELEASE_FLAGS "-O2 -mtune=generic -DNDEBUG")\n'
  '\n'
  '# Note: CLang does not work well with BZ_DEBUG\n'
  'set(COMMON_DEBUG_FLAGS "-g -DBOB_DEBUG")\n'
  '\n'
  'if(NOT APPLE OR CMAKE_COMPILER_IS_GNUCC) #linux builds or apple+gcc4.2\n'
  '  set(COMMON_DEBUG_FLAGS "${COMMON_DEBUG_FLAGS} -DBZ_DEBUG")\n'
  'endif()\n'
  '\n'
  '# These are used in type checks for cmake, be aware and don\'t change those\n'
  'set(CMAKE_CXX_FLAGS "${COMMON_CXX_FLAGS} ${COMMON_FLAGS}" CACHE STRING "Flags used by the compiler during release builds" FORCE)\n'
  'set(CMAKE_C_FLAGS "${COMMON_C_FLAGS} ${COMMON_FLAGS}" CACHE STRING "Flags used by the compiler during release builds" FORCE)\n'
  '\n'
  '# Cache into CMake\n'
  'set(CMAKE_CXX_FLAGS_RELEASE "${COMMON_RELEASE_FLAGS}" CACHE STRING "Flags used by the C++ compiler during release builds" FORCE)\n'
  'set(CMAKE_C_FLAGS_RELEASE "${COMMON_RELEASE_FLAGS}" CACHE STRING "Flags used by the C compiler during release builds" FORCE)\n'
  'set(CMAKE_CXX_FLAGS_DEBUG "${COMMON_DEBUG_FLAGS}" CACHE STRING "Flags used by the C++ compiler during debug builds" FORCE)\n'
  'set(CMAKE_C_FLAGS_DEBUG "${COMMON_DEBUG_FLAGS}" CACHE STRING "Flags used by the compiler C during debug builds" FORCE)\n'
  '\n'
  'set(BUILD_SHARED_LIBS "ON" CACHE BOOL "Build shared libs")\n\n'
)


class CMakeListsGenerator:
  """Generates a CMakeLists.txt file for the given sources, include directories and libraries."""

  def __init__(self, name, sources, target_directory, version = '1.0.0', include_directories = [], libraries = [], library_directories = [], macros = []):
    """Initializes the CMakeLists generator.

    Keyword parameters:

    name
      The name of the library to generate

    version
      The version of the library, major.minor.patch
    """

    self.name = name
    self.sources = sources
    self.target_directory = target_directory
    self.version = version
    self.includes = include_directories
    self.libraries = libraries
    self.library_directories = library_directories
    self.macros = macros

  def generate(self, directory):
    """Generates the CMakeLists.txt file in the given directory."""

    filename = os.path.join(directory, "CMakeLists.txt")
    with open(filename, 'w') as f:
      f.write('# WARNING! This file is automatically generated. Do not change its contents.\n\n')
      f.write('cmake_minimum_required(VERSION 2.8)\n')
      f.write('project(%s)\n' % self.name)
      f.write(HEADER)
      # add include directories
      for directory in self.includes:
        f.write('include_directories(SYSTEM %s)\n' % directory)
      # add defines
      for macro in self.macros:
        f.write('add_definitions(-D%s=%s)\n' % macro)
      # compile this library
      f.write('\nadd_library(${PROJECT_NAME} \n\t' + "\n\t".join(self.sources) + '\n)\n')
      f.write('set_target_properties(${PROJECT_NAME} PROPERTIES POSITION_INDEPENDENT_CODE TRUE SOVERSION "%s" VERSION "%s")\n\n' % (self.version.split('.')[0], '.'.join(self.version.split('.')[:2])))
      f.write('set_target_properties(${PROJECT_NAME} PROPERTIES LIBRARY_OUTPUT_DIRECTORY %s)\n' % self.target_directory)
      # link libraries
      for directory in self.library_directories:
        f.write('link_directories(%s)\n' % directory)
      if self.libraries:
        f.write('target_link_libraries(${PROJECT_NAME} %s\n\n' % " ".join(self.libraries))

